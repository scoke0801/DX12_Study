DirectX ?
GPU를 제어하고 프로그래밍하는데 쓰이는 저수준 그래픽 API


Com(Component Object Model)
DX의 프로그래밍 언어 독립성과 하위 호환성을 가능하게 하는 기술
COM객체(COM 인터페이스)를 사용, 세부 사항은 우리한테는 숨겨짐
ComPtr - COM객체를 다루는 일종의 스마트 포인터


 D3D12 디버그층  활성화
 - VC++ 출력창에 상세한 디버깅 메시지 출력
 - riid : 디바이스의 COM ID
 - ppDevice : 생성된 장치가 매개변수에 설정
#ifdef _DEBUG
	::D3D12GetDebugInterface(IID_PPV_ARGS(&_debugController));
	_debugController->EnableDebugLayer();
#endif


 DXGI(DirectX Graphics Infrastructure)
 Direct3D와 함께 쓰이는 API
 - 전체화면 모드 전환
 - 지원되는 디스플레이 모드 열거 등 
 CreateDXGIFactory
 - riid : 디바이스 COM ID
 - ppDevice: 생성된 장치가 매개변수에 설정
::CreateDXGIFactory(IID_PPV_ARGS(&_dxgi));


CreateDevice
- 디스플레이 어댑터(그래픽 카드)를 나타내는 객체
- pAdapter : nullptr 지정하면 시스템 기본 디스플레이 어댑터
- MinimumFeatureLevel : 응용 프로그램이 요구하는 최소 기능 수준(구닥다리 걸러낸다)
- riid : 디바이스의 COM id
- ppDevice : 생성된 장치가 매개변수에 설정
::D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&_device));


CommandQueue : DX12에 등장
외주를 요청할 때, 하나씩 요청하면 비효율적
[ 외주 목록 ]에 일감을 차곡차곡 기록했다가 한 방에 요청하는 것.
ComPtr<ID3D12CommandQueue>			_cmdQueue;	
ComPtr<ID3D12CommandAllocator>		_cmdAlloc;	// 메모리 공간
ComPtr<ID3D12GraphicsCommandList>	_cmdList;	// 일감 리스트


Fence : 울타리(?)
CPU / GPU 동기화를 위한 간단한 도구
ComPtr<ID3D12Fence>					_fence;
uint32								_fenceValue = 0;
HANDLE								_fenceEvent = INVALID_HANDLE_VALUE;


D3D12_COMMAND_QUEUE_DESC queueDesc = {};
queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;

device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&_cmdQueue));

- D3D12_COMMAND_LIST_TYPE_DIRECT : GPU가 직접 실행하는 명령 목록
device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&_cmdAlloc));

GPU가 하나인 시스템에서는 0으로
Direct or Bundle
Allocator
초기상태 (그리기 명령은 nullptr로 지정)
device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, _cmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_cmdList));

CommandList는 Close / Open상태가 있는데
Open 상태에서는 Command를 넣다가 Close한 다음 제출하는 개념.
_cmdList->Close();

CreateFence
- CPU와 GPU의 동기화 수단으로 사용
device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));
_fenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);


교환 사슬
[외주과정]
- 현재 게임 세상에 있는 상황을 묘사
- 어떤 공식으로 어떻게 계산할지를 던져줌
- GPU가 열심히 계산(외주)
- 결과물을 받아서 화면에 그려준다.

[외주 결과물]을 어디에 받지?
- 어떤 종이(Buffer)에 그려서 건내달라고 부탁해보자
- 특수 종이를 만들어서 -> 처음에 건내주고 -> 결과물을 해당 종이에 받는다.
- 우리 화면에 특수 종이(외주 결과물)를 출력해준다.

[?]
- 그런데 화면에 현재 결과물 출력는 와중에, 다음 화면도 외주를 맡겨야 함.
- 현재 화면 결과물은 이미 화면 출력에 사용중.
- 특수 종이를 2개 만들어서, 하나는 현재 화면을 그려주고 하나는 외주 맡기고
- Double Buffering

- [1] [2]
현재화면 [1] <-> GPU작업 [2] BackBuffer
SwapChain..

[기안서]
외주를 맡길 떄 이런 저런 정보들을 같이 넘겨줘야 하는데,
아무 형태로나 요청하면 못 알아먹는다.
- 각종 리소스를 어떤 용도로 사용하는지 꼼꼼하게 적어서 넘겨주는 용도
DesciptorHeap..
Desciptor ( Dx12에서의 호칭) ,,, View( ~Dx11까지의 호칭)
[서술자 힙]으로 RTV생성
DX11 의 RTV(RenderTargetView), DSV(DepthStencilView),
CBV(ConstantBufferView), SRV(SharedResourceView), UAV(UnorderedAccessView )를 전부!
같은 종류의 데이터끼리 배열로 관리.
RTV 목록: [] [] []
DSC목록 : [] [] []


// [ 계약서 / 결재 ] 
// 재료			-->외주		가공
// CPU [	]	-->외주		GPU [	]
// 한국	[	]	-->외주		베트남 [	]
RootSignature

어떤 데이터를 어떻게 활용할지를 루트 테이블로 만들어서 전달
루트 테이블?
API Bind Slot(외부 코드에서 몇번째 칸에 있는지를 지칭)  / root constant / HLSL bind slot(레지스터 슬롯)
root constant 자리에
root constant or root descriptor(view용도, 포인터 처럼 다른 리소스를 가리키는) or root table을 전달할 수 있음 
https://learn.microsoft.com/ko-kr/windows/win32/direct3d12/example-root-signatures


// 정점으로 이루어진 물체의 정보
Mesh


// [일감 기술서] 외주 인력들이 뭘 해야할지를 기술
Shader


// Material
어떤 쉐이더를 활용할 때, 해당 쉐이더에 전달하는 인자들을 포함하여 하나(의 클래스)로 관리


// 셰이더
GPU가 어떤 일을 하기 위해서 필요한 프로그램

// 리소스
셰이더로 전달해줘야 하는 데이터
크게 구분하면 텍스쳐와 버퍼

// 텍스쳐
이미지, 그림 데이터를 담음

// 버퍼
행렬, 벡터, 사용자 정의 자료형 등의 데이터를 담음

// 리소스 뷰
뷰(View) or 서술자(Descriptor)
DX11까지 뷰라는 용어를 사용, DX12에서는 뷰라는 용어와 서술자라는 용어를 같이 사용
ex) Device->CreateRenderTargetView / CreateDescriptorHeap
서술자는 하나의 리소스에 대한 정보를 포함하는 자료구조를 의미
리소스 뷰는 리소스를 바라보는 관점을 어떻게 할 것인지를 담은 자료구조?
->리소스를 어떻게 사용할 것인지...

DX12에서 쉐이더 프로그램은 리소스를 직접 전달받아서 사용하는 것이 아니라
리소스 뷰를 전달받아서 사용한다.

// 리소스 힙 타입
D3D12_HEAP_TYPE_DEFAULT는 CPU는 접근 불가능하고 GPU는 접근 가능한 타입
-> 속도가 빠름
-> CPU의 데이터를 리소스에 담아야 하는데, CPU의 접근이 불가능하면??
-> 리소스를 전달하기 위해 D3D12_HEAP_TYPE_UPLOAD 타입의 버퍼를 사용
-> D3D12_HEAP_TYPE_UPLOAD 타입은 CPU, GPU모두 접근 가능

// D3D12_HEAP_TYPE_DEFAULT 타입의 리소스에 데이터 담기
CPU가 upload 버퍼에 데이터를 올리고 default 버퍼에 데이터를 복사?


// 조명
유니티 기준
Directional
모든 방향으로 영향을 주는 광원
태양같은 느낌

Po int
위치에서 특점 지점까지만 영향을 주는 광원
횃불같은 느낌

Spot
하이라이트, 스포트라이트, 손전등 

diffuse		난반사광
ambient		환경광
sepcular	정반사광

법선 벡터 : 평면에 수직하는 벡터
탄젠트 벡터 : 평면에 접하는 벡터
바이노말 벡터 : 법선 벡터, 탄젠트 벡터를 외적한 결과 벡터

빛이라는 것은 
물체가 가지고 있던 색상에 곱하는 값을 계산해주는 과정...